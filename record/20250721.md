### proxy
1. 要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作
2. 如果handler没有设置任何拦截，那就等同于直接通向原对象。
   ``` javascript
    var target = {};
    var handler = {};
    var proxy = new Proxy(target, handler);
    proxy.a = 'b';
    target.a // "b"
3. 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。
   ```
   var object = { proxy: new Proxy(target, handler) };
4. Proxy 实例也可以作为其他对象的原型对象。
   ``` javascript
   var proxy = new Proxy({}, {
    get: function(target, propKey) {
    return 35;
    }
   });
    let obj = Object.create(proxy);
    obj.time // 35
5. proxy身上的receiver参数是原始的读操作所在的那个对象
   ``` javascript
   const proxy = new Proxy({}, {
    get: function(target, key, receiver) {
    return receiver;
     }
    });
    const d = Object.create(proxy);
    d.a === d // true
6. - js中字符串支持下标访问
   -  字符串有 length 属性
   -  字符串不能通过下标修改内容
   -  字符串没有数组的修改方法（push、pop 等）
7. Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。
   + 结构：Object.create(proto, propertiesObject)
   + proto：新创建对象的原型对象。
   + propertiesObject：如果该参数被指定且不为 undefined，则该传入对象可枚举的自有属性将为新创建的对象添加具有对应属性名称的属性描述符。这些属性对应于 Object.defineProperties() 的第二个参数。
   + 默认情况下，属性是不可写、可枚举和可配置的。
```javascript
       o = {};
// 等价于：
o = Object.create(Object.prototype);

o = Object.create(Object.prototype, {
  // foo 是一个常规数据属性
  foo: {
    writable: true,
    configurable: true,
    value: "hello",
  },
  // bar 是一个访问器属性
  bar: {
    configurable: false,
    get() {
      return 10;
    },
    set(value) {
      console.log("Setting `o.bar` to", value);
    },
  },
});

// 创建一个新对象，它的原型是一个新的空对象，并添加一个名为 'p'，值为 42 的属性。
o = Object.create({}, { p: { value: 42 } });
```
8. set代理应当返回一个布尔值。严格模式下，set代理如果没有返回true，就会报错。
9. Object.setPrototypeOf() 静态方法可以将一个指定对象的原型（即内部的 [[Prototype]] 属性）设置为另一个对象或者 null。
    + 语法：Object.setPrototypeOf(obj, prototype)
    + obj:要设置其原型的对象。
    + prototype:该对象的新原型（一个对象或 null）。
10. Object.defineProperty 的属性描述符分为两类：数据描述符 和存取描述符 ，以及共享描述符 。
    + 数据描述符:用于定义属性的值和可写性。独有属性：1.value：设置属性的值，默认值 ：undefined；2.writable：控制属性值是否可以被修改，默认值：false
    + 存取描述符:用于定义 getter 和 setter 函数。独有属性：1.get：定义属性的 getter 函数，默认值：undefined；2.set：定义属性的 setter 函数，默认值：undefined
    + 共享描述符:两种描述符类型都可以使用的属性。1.enumerable：控制属性是否在枚举中显示，默认值：false；2.configurable：控制属性描述符是否可以被修改，以及属性是否可以被删除，默认值：false；
    + 注意事项：1.同一属性不能同时使用数据描述符和存取描述符；
11. ES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。
    + ES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。
    + 举例来说，obj是一个 Record，它有一个Prototype属性。ES6 规格不会写obj.Prototype，而是写obj.[[Prototype]]。一般来说，使用[[Notation]]这种书写法的属性，都是对象的内部属性。
    + 所有的 JavaScript 函数都有一个内部属性[[Call]]，用来运行该函数。F.[[Call]](V, argumentsList)
12. 每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。[[Type]]属性有五种可能的值。
    + normal
    + return
    + throw
    + break
    + continue
  
    如果[[Type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[Type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。
13. Function 实例的 call() 方法会以给定的 this 值和逐个提供的参数调用该函数。
    + call(thisArg, arg1, arg2, /* …, */ argN)
    + thisArg:在调用 func 时要使用的 this 值。如果函数不在严格模式下，null 和 undefined 将被替换为全局对象，并且原始值将被转换为对象。不传是undefined
    + arg1, arg2, /* …, */ argN：函数的参数。
14. Function 实例的 apply() 方法会以给定的 this 值和作为数组（或类数组对象）提供的 arguments 调用该函数。
15. Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。Function.prototype.apply.call(fn, obj, args)
16. apply方法拦截函数的调用、call和apply操作。apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
17. has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。
18. Object.preventExtensions() 静态方法可以防止新属性被添加到对象中（即防止该对象被扩展）。它还可以防止对象的原型被重新指定。Object.preventExtensions(obj)=》obj：将要变得不可扩展的对象。返回值：已经不可扩展的对象。
19. Object.getOwnPropertyDescriptor() 静态方法返回一个对象，该对象描述给定对象上特定属性（即直接存在于对象上而不在对象的原型链中的属性）的配置。返回的对象是可变的，但对其进行更改不会影响原始属性的配置。Object.getOwnPropertyDescriptor(obj, prop)
20. Object.getPrototypeOf() 静态方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。Object.getPrototypeOf(obj)
21. Object.isExtensible() 静态方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。Object.isExtensible(obj)
22. Object.getOwnPropertyNames() 静态方法返回一个数组，其包含给定对象中所有自有属性（包括不可枚举属性，但不包括使用 symbol 值作为名称的属性）。
23. Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。
    ```javascript
    let p = {
    a: 'a'
      };

    let handler = {
      set(target, key, value, receiver) {
        console.log('set');
        Reflect.set(target, key, value, receiver)
      },
      defineProperty(target, key, attribute) {
        console.log('defineProperty');
        Reflect.defineProperty(target, key, attribute);
      }
    };

    let obj = new Proxy(p, handler);
    obj.a = 'A';
    // set
    // defineProperty
   + Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截
   + defineProperty里要显式返回true才能执行赋值操作，类似：
      ```javascript
      defineProperty(target, property, attribute) {
        const result = Reflect.defineProperty(target, property, attribute)
        return result
      }
      defineProperty(target, property, attribute) {
        // 必须实际执行定义操作
        return Reflect.defineProperty(target, property, attribute)
      }
24. + 拓展运算符（Spread Operator）：将可迭代对象（数组、字符串、Set等）或对象展开成独立的元素。扩展运算符（...）内部使用for...of循环,对象内部没有可迭代属性，{...obj}是对象的展开语法，不是拓展运算符语法
    + 剩余参数（Rest Parameters）：将多个独立的参数收集成一个数组
25. 任何具有 Iterable 接口的对象指的是任何实现了 JavaScript 可迭代协议的对象。在 JavaScript 中，Iterable 接口是一个约定，要求对象必须实现一个名为 @@iterator 的方法（即 Symbol.iterator 属性），该方法返回一个迭代器对象。
    + 对象实现了 Symbol.iterator 方法
    + 该方法返回一个迭代器对象
    + 迭代器对象有 next() 方法，能逐个返回值
    + 可以被 for...of、展开运算符等语法使用
   ```javascript
   const myIterable = {
    data: [1, 2, 3],
    [Symbol.iterator]() {
      let index = 0
      const data = this.data
      return {
        next() {
          if (index < data.length) {
            return { value: data[index++], done: false }
          } else {
            return { done: true }
          }
        }
      }
    }
  }
    console.log(...myIterable) // 1 2 3   
  ```

26. for...of 语句执行一个循环，该循环处理来自可迭代对象的值序列。可迭代对象包括内置对象的实例，例如 Array、String、TypedArray、Map、Set、NodeList（以及其他 DOM 集合），还包括 arguments 对象、由生成器函数生成的生成器，以及用户定义的可迭代对象。
    + 只调用一次 iterable[Symbol.iterator]() 获取迭代器
    + 多次调用 迭代器的 next() 方法获取值
    + 每次获取一个值就立即赋值给变量并执行循环体
    + for...in 语句迭代一个对象的所有可枚举字符串属性（除 Symbol 以外），包括继承的可枚举属性。该循环将迭代对象本身的所有可枚举属性，以及对象从其原型链继承的属性（原型链中较近的原型的属性优先于较远的原型的属性）。for in 包括原型属性属性名，for of只是遍历自身属性值
27. Array.from() 静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。
    + Array.from(arrayLike, mapFn, thisArg)
    + arrayLike：想要转换成数组的类数组或可迭代对象。类数组对象指的是：有 length 属性，属性键为非负整数（0, 1, 2, ...），没有数组的方法（如 push, pop, slice 等）
    + mapFn：调用数组每个元素的函数。如果提供，每个将要添加到数组中的值首先会传递给该函数，然后将 mapFn 的返回值增加到数组中。使用以下参数调用该函数：element:数组当前正在处理的元素。index:数组当前正在处理的元素的索引。(只有两个参数)
    + thisArg:执行 mapFn 时用作 this 的值。
28. ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
    + Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。
    + Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。
  
       操作方法：
       1. Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
       2. Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
       3. Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
       4. Set.prototype.clear()：清除所有成员，没有返回值。
      遍历方法：
       5. Set.prototype.keys()：返回键名的遍历器
       6. Set.prototype.values()：返回键值的遍历器
       7. Set.prototype.entries()：返回键值对的遍历器
       8. Set.prototype.forEach()：使用回调函数遍历每个成员
       9. 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。
       10. Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
          ```javascript
          Set.prototype[Symbol.iterator] === Set.prototype.values
          // true
          ```
          这意味着，可以省略values方法，直接用for...of循环遍历 Set。
          ```javascript
          let set = new Set(['red', 'green', 'blue']);

            for (let x of set) {
              console.log(x);
            }
            // red
            // green
            // blue
            ```
29. WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
    + 首先，WeakSet 的成员只能是对象和 Symbol 值，而不能是其他类型的值。
    + 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
    + WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员，返回 WeakSet 结构本身。
    + WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员，清除成功返回true，如果在 WeakSet 中找不到该成员或该成员不是对象，返回false。
    + WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
30. ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
    + 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。
     ```javascript 
    const map = new Map([
      ['name', '张三'],
      ['title', 'Author']
    ]);

    map.size // 2
    map.has('name') // true
    map.get('name') // "张三"
    map.has('title') // true
    map.get('title') // "Author"
    const items = [
      ['name', '张三'],
      ['title', 'Author']
    ];
    const map = new Map();
    items.forEach(
      ([key, value]) => map.set(key, value)
    );
    ```
    + Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。
  
      ` map[Symbol.iterator] === map.entries
      //true`
31. WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点。
    + 首先，WeakMap只接受对象（null除外）和 Symbol 值作为键名，不接受其他类型的值作为键名。
    + 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。
    ```javascript
        const wm = new WeakMap();
        const element = document.getElementById('example');
        wm.set(element, 'some information');
        wm.get(element) // "some information"
    ```
    + WeakMap只有四个方法可用：get()、set()、has()、delete()。
32. 类是构造函数的语法糖
    ```javascript
        class Point {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }

          toString() {
            return '(' + this.x + ', ' + this.y + ')';
      }
      typeof Point // "function"
      Point === Point.prototype.constructor // true
      ```
     + 定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。
     + 类的数据类型就是函数，类本身就指向构造函数。
     + 类的所有方法都定义在类的prototype属性上面。
     + prototype对象的constructor属性，直接指向“类”的本身
     + 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
     ```javascript
        Object.keys(Point.prototype)
        // []
        Object.getOwnPropertyNames(Point.prototype)
        // ["constructor","toString"]
     ```
33. Object.assign() 静态方法将一个或者多个源对象中所有可枚举的自有属性复制到目标对象，并返回修改后的目标对象。Object.assign(target, ...sources)==>target:需要应用源对象属性的目标对象，修改后将作为返回值。sources:一个或多个包含要应用的属性的源对象。字符串和 Symbol 类型属性都会被复制。
    ```javascript 
       Object.assign(Point.prototype, {
        toString(){},
        toValue(){}
      });
34. constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。
    ```javascript
       class Foo {
        constructor() {
          return Object.create(null);
        }
      }

      new Foo() instanceof Foo
      // false
35. 类的属性和方法，除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。与 ES5 一样，类的所有实例共享一个原型对象。ES2022 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在constructor()方法里面的this上面，也可以定义在类内部的最顶层。
    ```javascript 
        class IncreasingCounter {
          _count = 0;
          get value() {
            console.log('Getting the current value!');
            return this._count;
          }
          increment() {
            this._count++;
          }
        }
    上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。
36. 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。存值函数和取值函数是设置在属性的 Descriptor 对象上的。class 语法定义的存取器默认是 enumerable: true 和 configurable: true
    ```javascript 
        class CustomHTMLElement {
        constructor(element) {
          this.element = element;
        }

        get html() {
          return this.element.innerHTML;
        }

        set html(value) {
          this.element.innerHTML = value;
        }
      }
      Object.defineProperty(Person.prototype, 'html', {
          get: function() {
            return this.element.innerHTML;
          },
          set: function(value) {
            this.element.innerHTML = value;
          },
          enumerable: true,  // 注意这个属性
          configurable: true // 注意这个属性
      });
      var descriptor = Object.getOwnPropertyDescriptor(
        CustomHTMLElement.prototype, "html"
      );
      // {
      //   get: [Function: get html],
      //   set: [Function: set html],
      //   enumerable: true,    // 注意这里是 true
      //   configurable: true   // 注意这里是 true
      // }
      "get" in descriptor  // true
      "set" in descriptor  // true
37. 类的属性名，可以采用表达式。
    ```javascript 
       let methodName = 'getArea';
        class Square {
          constructor(length) {
            // ...
          }

          [methodName]() {
            // ...
          }
        } 

1. ES2020 引入了“链判断运算符”（optional chaining operator）?.左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。
   + 判断对象方法是否存在iterator.return?.()上面代码中，iterator.return如果有定义，就会调用该方法，否则iterator.return直接返回undefined，不再执行?.后面的部分。
   + a?.b等同于a == null ? undefined : a.b
   + 以下写法会报错：1. 构造函数new a?.()；2.链判断运算符的右侧有模板字符串：a?.`{b}`；3.链判断运算符的左侧是 super：super?.()4.链运算符用于赋值运算符左侧：a?.b = c
2. ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。默认值只有在左侧属性值为null或undefined时，才会生效。
   ```javascript
      const headerText = response.settings.headerText ?? 'Hello, world!';
    ```
    这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。
    ```javascript
    const animationDuration = response.settings?.animationDuration ?? 300;
    ```
    ??本质上是逻辑运算，它与其他两个逻辑运算符&&和||有一个优先级问题,如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。
3. ES2021 引入了三个新的逻辑赋值运算符（logical assignment operators），将逻辑运算符与赋值运算符进行结合
   ```javascript
      // 或赋值运算符
         x ||= y
         // 等同于
         x || (x = y)

         // 与赋值运算符
         x &&= y
         // 等同于
         x && (x = y)

         // Null 赋值运算符
         x ??= y
         // 等同于
         x ?? (x = y)
         <!-- 用法 -->
         // 老的写法
        user.id = user.id || 1;

        // 新的写法
        user.id ||= 1;
   ```
4. 简写的对象方法不能用作构造函数，会报错。
   ```javascript
      const obj = {
     f() {
         this.foo = 'bar';
     }
     };//new obj.f() 报错
   ```
5. 属性名表达式与简洁表示法，不能同时使用，会报错。
   ```javascript
     // 报错
    const foo = 'bar';
    const bar = 'abc';
    const baz = { [foo] };

    // 正确
    const foo = 'bar';
    const baz = { [foo]: 'abc'};  
   ```
6. 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]
   ```javascript
     const keyA = {a: 1};
     const keyB = {b: 2};

     const myObject = {
     [keyA]: 'valueA',
     [keyB]: 'valueB'
     };
     myObject // Object {[object Object]: "valueB"}
    ```
7. ES6 新增了关键字super，指向当前对象的原型对象。super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。
   ```javascript
      const proto = {
        x: 'hello',
        foo() {
            console.log(this.x);
        },
        };

        const obj = {
        x: 'world',
        foo() {
            super.foo();
        }
        }

        Object.setPrototypeOf(obj, proto);

        obj.foo() // "world"
    ```
8. 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
   ```javascript
       let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
         x // 1
         y // 2
         z // { a: 3, b: 4 }
   ```
   + 解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象
   + 解构赋值必须是最后一个参数，否则会报错。
   + 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
   + 扩展运算符的解构赋值，不能复制继承自原型对象的属性。
   + 单纯解构赋值可以读取原型上的属性，但是拓展运算符的解构赋值只能读取对象自身的属性
     ```javascript
        const o = Object.create({ x: 1, y: 2 });
        o.z = 3;

        let { x, ...newObj } = o;
        let { y, z } = newObj;
        x // 1
        y // undefined
        z // 3
     ```
9. 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
    ```javascript
     let foo = { ...['a', 'b', 'c'] };
     foo
     // {0: "a", 1: "b", 2: "c"}
     ```
     + 如果扩展运算符后面不是对象，则会自动将其转为对象。
     ```javascript
            // 等同于 {...Object(true)}
        {...true} // {}

        // 等同于 {...Object(undefined)}
        {...undefined} // {}

        // 等同于 {...Object(null)}
        {...null} // {}
        <!-- 如果扩展运算符后面是一个空对象，则没有任何效果。 -->
        {...{}, a: 1}
        // { a: 1 }     
    ```
    + 如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象
    ```javascript
       {...'hello'}
    // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
    ```
    + 对象的扩展运算符，只会返回参数对象自身的、可枚举的属性
    ```javascript 
    class C {
    p = 12;
    m() {}
        }

    let c = new C();
    let clone = { ...c };
    clone.p; // ok
    clone.m(); // 报错
    ```
    + 对象的扩展运算符等同于使用Object.assign()方法。
   ```javascript
   let aClone = { ...a };
    // 等同于
    let aClone = Object.assign({}, a);
   ```
    + 扩展运算符可以用于合并两个对象。
    ```javascript
    let aWithOverrides = { ...a, x: 1, y: 2 };
    // 等同于
    let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
    // 等同于
    let x = 1, y = 2, aWithOverrides = { ...a, x, y };
    // 等同于
    let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
   ```
    + 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。
    ```javascript
        const obj = {
        ...(x > 1 ? {a: 1} : {}),
        b: 2,
        };
        let a = {
        get x() {
            throw new Error('not throw yet');
        }
        }

        let aWithXGetter = { ...a }; // 报错
    ```
10. ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
    ```javascript
    +0 === -0 //true
    NaN === NaN // false

    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
    ```
11. [[PrimitiveValue]] 是 JavaScript 引擎内部用于存储包装对象所包装的原始值的一个内部插槽（Internal Slot）。[[PrimitiveValue]] 就是包装对象“背后真正保存的那个原始值”。 只有字符串的包装对象，会产生可枚举的实义属性
    ```javascript
       new String('abc')
       <!-- 引擎会创建一个对象，并设置其 [[PrimitiveValue]] 为 'abc'。 -->
       <!-- 调用 .valueOf() 方法时，会返回 [[PrimitiveValue]] 的值： -->
       new Number(42).valueOf(); // 42
       在类型转换时（如字符串拼接），也会用到它：
       const s = new String('hi');
       console.log(s + ' there'); // 'hi there' → 先取出 [[PrimitiveValue]]
    ```
12. 自动装箱（Auto-boxing）：
当你尝试访问一个原始值的属性或方法时，JavaScript 会临时将其包装成对应的包装对象（如 String、Number、Boolean），以便调用方法或访问属性。 这个包装对象在操作完成后就被丢弃。
13. Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。
    ```javascript
      // 例一
    const entries = new Map([
    ['foo', 'bar'],
    ['baz', 42]
    ]);

    Object.fromEntries(entries)
    // { foo: "bar", baz: 42 }

    // 例二
    const map = new Map().set('foo', true).set('bar', false);
    Object.fromEntries(map)
    // { foo: true, bar: false } 
    ```
14. ES2022 在Object对象上面新增了一个静态方法Object.hasOwn()，也可以判断是否为自身的属性。Object.hasOwn()的一个好处是，对于不继承Object.prototype的对象不会报错，而hasOwnProperty()是会报错的。
    ```javascript
    const foo = Object.create({ a: 123 });
    foo.b = 456;

    Object.hasOwn(foo, 'a') // false
    Object.hasOwn(foo, 'b') // true
    const obj = Object.create(null);

    obj.hasOwnProperty('foo') // 报错
    Object.hasOwn(obj, 'foo') // false
    ```
15. 在for...in/for...of中使用let/const时，每次迭代会创建新绑定，循环内部每次会产生一个新的词法环境，循环变量是不断更新的，for(const i=0;i<10;i++)会直接报错.
16. 函数运行时能访问自身名字，是因为在函数执行时，JS 引擎在“函数自身的词法环境记录”中创建了一个只读绑定，这个绑定的值指向函数对象本身.这个过程依赖于 [[FunctionName]]，但访问时是通过“运行时创建的词法环境”完成的，而不是直接读取 [[FunctionName]]:1).函数名绑定是运行时创建的;2).绑定在函数自身的词法环境记录中;3).不是直接从 [[FunctionName]] 读取（但 [[FunctionName]] 是创建这个绑定的依据）
    

    阶段1：函数创建时（Create Time）
    + 创建函数对象
    + 设置内部槽：[[FunctionName]]: "factorial";[[ECMAScriptCode]]: ...;[[Environment]]: <外层词法环境>（用于闭包）;[[Call]], [[Construct]], 等
  
    此时，factorial 还不能在代码中访问，因为没有绑定到任何环境

    阶段 2：函数调用时（Call Time）
    + 创建新的 函数执行上下文
    + 创建一个 Function Environment Record（函数环境记录）
    + 检查函数的 [[FunctionName]]
    + 如果 [[FunctionName]] 非空（如 "factorial"），则：1).在这个 Function Environment Record 中创建一个不可变绑定（immutable binding）;2).名称为 factorial;3).值为该函数对象本身
    + 将执行上下文的 LexicalEnvironment 指向这个环境记录
    此时，factorial 才真正“变得可访问”。
    ```javascript
        const f = function factorial(n) {
        return n * factorial(n - 1);
        };
        f(3);
        <!-- 执行上下文 {
        ThisBinding: ...
        LexicalEnvironment: → FunctionEnvRecord {
                        n: 3,
                        factorial: → 指向函数对象（只读）
                      }
        VariableEnvironment: 同上（初始）
                        } -->
     ```
17. 函数对象包含对外可见的部分(可以在js中访问)和内部槽(引擎私有，js无法直接访问)
    ```javascript
       function foo(x){
        return x*2
       }
       1. 对外可见的部分
       foo.name:"foo"(来自[[FunctionName]])
       foo.length:1(参数个数)
       foo.prototype:函数的原型对象(用于构造函数)
       foo.toString():返回函数源码字符串
       这些是函数对象的"公开接口"
       2.内部槽(internal slots)(引擎私有，js无法直接访问)
       [[Call]]:定义函数被调用时的行为（执行逻辑）
       [[Construct]]:定义new foo()时的行为
       [[ECMAScriptCode]]:指向函数体的 AST 或字节码（即“代码”本身）
       [[Environment]]:指向定义时的词法环境（用于闭包）
       [[FunctionName]]:函数名称（如"foo"）
       [[FormalParameters]]:	参数列表（如"x"）
       [[ThisMode]]:"lexical"（箭头函数）或"global"/"strict"
       [[HomeObject]]:用于super调用（ES6 类）
       [[Realm]]:	关联的执行环境（Realm）
       ......
       ```










       

