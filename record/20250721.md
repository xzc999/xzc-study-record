### proxy
1. 要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作
2. 如果handler没有设置任何拦截，那就等同于直接通向原对象。
   ``` javascript
    var target = {};
    var handler = {};
    var proxy = new Proxy(target, handler);
    proxy.a = 'b';
    target.a // "b"
3. 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。
   ```
   var object = { proxy: new Proxy(target, handler) };
4. Proxy 实例也可以作为其他对象的原型对象。
   ``` javascript
   var proxy = new Proxy({}, {
    get: function(target, propKey) {
    return 35;
    }
   });
    let obj = Object.create(proxy);
    obj.time // 35
5. proxy身上的receiver参数是原始的读操作所在的那个对象
   ``` javascript
   const proxy = new Proxy({}, {
    get: function(target, key, receiver) {
    return receiver;
     }
    });
    const d = Object.create(proxy);
    d.a === d // true
6. - js中字符串支持下标访问
   -  字符串有 length 属性
   -  字符串不能通过下标修改内容
   -  字符串没有数组的修改方法（push、pop 等）
7. Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。
   + 结构：Object.create(proto, propertiesObject)
   + proto：新创建对象的原型对象。
   + propertiesObject：如果该参数被指定且不为 undefined，则该传入对象可枚举的自有属性将为新创建的对象添加具有对应属性名称的属性描述符。这些属性对应于 Object.defineProperties() 的第二个参数。
   + 默认情况下，属性是不可写、可枚举和可配置的。
```javascript
       o = {};
// 等价于：
o = Object.create(Object.prototype);

o = Object.create(Object.prototype, {
  // foo 是一个常规数据属性
  foo: {
    writable: true,
    configurable: true,
    value: "hello",
  },
  // bar 是一个访问器属性
  bar: {
    configurable: false,
    get() {
      return 10;
    },
    set(value) {
      console.log("Setting `o.bar` to", value);
    },
  },
});

// 创建一个新对象，它的原型是一个新的空对象，并添加一个名为 'p'，值为 42 的属性。
o = Object.create({}, { p: { value: 42 } });
```
8. set代理应当返回一个布尔值。严格模式下，set代理如果没有返回true，就会报错。
9. Object.setPrototypeOf() 静态方法可以将一个指定对象的原型（即内部的 [[Prototype]] 属性）设置为另一个对象或者 null。
    + 语法：Object.setPrototypeOf(obj, prototype)
    + obj:要设置其原型的对象。
    + prototype:该对象的新原型（一个对象或 null）。
10. Object.defineProperty 的属性描述符分为两类：数据描述符 和存取描述符 ，以及共享描述符 。
    + 数据描述符:用于定义属性的值和可写性。独有属性：1.value：设置属性的值，默认值 ：undefined；2.writable：控制属性值是否可以被修改，默认值：false
    + 存取描述符:用于定义 getter 和 setter 函数。独有属性：1.get：定义属性的 getter 函数，默认值：undefined；2.set：定义属性的 setter 函数，默认值：undefined
    + 共享描述符:两种描述符类型都可以使用的属性。1.enumerable：控制属性是否在枚举中显示，默认值：false；2.configurable：控制属性描述符是否可以被修改，以及属性是否可以被删除，默认值：false；
    + 注意事项：1.同一属性不能同时使用数据描述符和存取描述符；
11. ES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。
    + ES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。
    + 举例来说，obj是一个 Record，它有一个Prototype属性。ES6 规格不会写obj.Prototype，而是写obj.[[Prototype]]。一般来说，使用[[Notation]]这种书写法的属性，都是对象的内部属性。
    + 所有的 JavaScript 函数都有一个内部属性[[Call]]，用来运行该函数。F.[[Call]](V, argumentsList)
12. 每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。[[Type]]属性有五种可能的值。
    + normal
    + return
    + throw
    + break
    + continue
  
    如果[[Type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[Type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。
13. Function 实例的 call() 方法会以给定的 this 值和逐个提供的参数调用该函数。
    + call(thisArg, arg1, arg2, /* …, */ argN)
    + thisArg:在调用 func 时要使用的 this 值。如果函数不在严格模式下，null 和 undefined 将被替换为全局对象，并且原始值将被转换为对象。不传是undefined
    + arg1, arg2, /* …, */ argN：函数的参数。
14. Function 实例的 apply() 方法会以给定的 this 值和作为数组（或类数组对象）提供的 arguments 调用该函数。
15. Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。Function.prototype.apply.call(fn, obj, args)
16. apply方法拦截函数的调用、call和apply操作。apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
17. has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。
18. Object.preventExtensions() 静态方法可以防止新属性被添加到对象中（即防止该对象被扩展）。它还可以防止对象的原型被重新指定。Object.preventExtensions(obj)=》obj：将要变得不可扩展的对象。返回值：已经不可扩展的对象。
19. Object.getOwnPropertyDescriptor() 静态方法返回一个对象，该对象描述给定对象上特定属性（即直接存在于对象上而不在对象的原型链中的属性）的配置。返回的对象是可变的，但对其进行更改不会影响原始属性的配置。Object.getOwnPropertyDescriptor(obj, prop)
20. Object.getPrototypeOf() 静态方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。Object.getPrototypeOf(obj)
21. Object.isExtensible() 静态方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。Object.isExtensible(obj)
22. Object.getOwnPropertyNames() 静态方法返回一个数组，其包含给定对象中所有自有属性（包括不可枚举属性，但不包括使用 symbol 值作为名称的属性）。
23. Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。
    ```javascript
    let p = {
    a: 'a'
      };

    let handler = {
      set(target, key, value, receiver) {
        console.log('set');
        Reflect.set(target, key, value, receiver)
      },
      defineProperty(target, key, attribute) {
        console.log('defineProperty');
        Reflect.defineProperty(target, key, attribute);
      }
    };

    let obj = new Proxy(p, handler);
    obj.a = 'A';
    // set
    // defineProperty
   + Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截
   + defineProperty里要显式返回true才能执行赋值操作，类似：
      ```javascript
      defineProperty(target, property, attribute) {
        const result = Reflect.defineProperty(target, property, attribute)
        return result
      }
      defineProperty(target, property, attribute) {
        // 必须实际执行定义操作
        return Reflect.defineProperty(target, property, attribute)
      }
24. + 拓展运算符（Spread Operator）：将可迭代对象（数组、字符串、Set等）或对象展开成独立的元素。扩展运算符（...）内部使用for...of循环,对象内部没有可迭代属性，{...obj}是对象的展开语法，不是拓展运算符语法
    + 剩余参数（Rest Parameters）：将多个独立的参数收集成一个数组
25. 任何具有 Iterable 接口的对象指的是任何实现了 JavaScript 可迭代协议的对象。在 JavaScript 中，Iterable 接口是一个约定，要求对象必须实现一个名为 @@iterator 的方法（即 Symbol.iterator 属性），该方法返回一个迭代器对象。
    + 对象实现了 Symbol.iterator 方法
    + 该方法返回一个迭代器对象
    + 迭代器对象有 next() 方法，能逐个返回值
    + 可以被 for...of、展开运算符等语法使用
   ```javascript
   const myIterable = {
    data: [1, 2, 3],
    [Symbol.iterator]() {
      let index = 0
      const data = this.data
      return {
        next() {
          if (index < data.length) {
            return { value: data[index++], done: false }
          } else {
            return { done: true }
          }
        }
      }
    }
  }
    console.log(...myIterable) // 1 2 3   
  ```

26. for...of 语句执行一个循环，该循环处理来自可迭代对象的值序列。可迭代对象包括内置对象的实例，例如 Array、String、TypedArray、Map、Set、NodeList（以及其他 DOM 集合），还包括 arguments 对象、由生成器函数生成的生成器，以及用户定义的可迭代对象。
    + 只调用一次 iterable[Symbol.iterator]() 获取迭代器
    + 多次调用 迭代器的 next() 方法获取值
    + 每次获取一个值就立即赋值给变量并执行循环体
    + for...in 语句迭代一个对象的所有可枚举字符串属性（除 Symbol 以外），包括继承的可枚举属性。该循环将迭代对象本身的所有可枚举属性，以及对象从其原型链继承的属性（原型链中较近的原型的属性优先于较远的原型的属性）。for in 包括原型属性属性名，for of只是遍历自身属性值
27. Array.from() 静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。
    + Array.from(arrayLike, mapFn, thisArg)
    + arrayLike：想要转换成数组的类数组或可迭代对象。类数组对象指的是：有 length 属性，属性键为非负整数（0, 1, 2, ...），没有数组的方法（如 push, pop, slice 等）
    + mapFn：调用数组每个元素的函数。如果提供，每个将要添加到数组中的值首先会传递给该函数，然后将 mapFn 的返回值增加到数组中。使用以下参数调用该函数：element:数组当前正在处理的元素。index:数组当前正在处理的元素的索引。(只有两个参数)
    + thisArg:执行 mapFn 时用作 this 的值。
28. ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
    + Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。
    + Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。
  
       操作方法：
       1. Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
       2. Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
       3. Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
       4. Set.prototype.clear()：清除所有成员，没有返回值。
      遍历方法：
       5. Set.prototype.keys()：返回键名的遍历器
       6. Set.prototype.values()：返回键值的遍历器
       7. Set.prototype.entries()：返回键值对的遍历器
       8. Set.prototype.forEach()：使用回调函数遍历每个成员
       9. 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。
       10. Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
          ```javascript
          Set.prototype[Symbol.iterator] === Set.prototype.values
          // true
          ```
          这意味着，可以省略values方法，直接用for...of循环遍历 Set。
          ```javascript
          let set = new Set(['red', 'green', 'blue']);

            for (let x of set) {
              console.log(x);
            }
            // red
            // green
            // blue
            ```
29. WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
    + 首先，WeakSet 的成员只能是对象和 Symbol 值，而不能是其他类型的值。
    + 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
    + WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员，返回 WeakSet 结构本身。
    + WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员，清除成功返回true，如果在 WeakSet 中找不到该成员或该成员不是对象，返回false。
    + WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
30. ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
    + 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。
     ```javascript 
    const map = new Map([
      ['name', '张三'],
      ['title', 'Author']
    ]);

    map.size // 2
    map.has('name') // true
    map.get('name') // "张三"
    map.has('title') // true
    map.get('title') // "Author"
    const items = [
      ['name', '张三'],
      ['title', 'Author']
    ];
    const map = new Map();
    items.forEach(
      ([key, value]) => map.set(key, value)
    );
    ```
    + Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。
  
      ` map[Symbol.iterator] === map.entries
      //true`
31. WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点。
    + 首先，WeakMap只接受对象（null除外）和 Symbol 值作为键名，不接受其他类型的值作为键名。
    + 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。
    ```javascript
        const wm = new WeakMap();
        const element = document.getElementById('example');
        wm.set(element, 'some information');
        wm.get(element) // "some information"
    ```
    + WeakMap只有四个方法可用：get()、set()、has()、delete()。
32. 类是构造函数的语法糖
    ```javascript
        class Point {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }

          toString() {
            return '(' + this.x + ', ' + this.y + ')';
      }
      typeof Point // "function"
      Point === Point.prototype.constructor // true
      ```
     + 定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。
     + 类的数据类型就是函数，类本身就指向构造函数。
     + 类的所有方法都定义在类的prototype属性上面。
     + prototype对象的constructor属性，直接指向“类”的本身
     + 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
     ```javascript
        Object.keys(Point.prototype)
        // []
        Object.getOwnPropertyNames(Point.prototype)
        // ["constructor","toString"]
     ```
33. Object.assign() 静态方法将一个或者多个源对象中所有可枚举的自有属性复制到目标对象，并返回修改后的目标对象。Object.assign(target, ...sources)==>target:需要应用源对象属性的目标对象，修改后将作为返回值。sources:一个或多个包含要应用的属性的源对象。字符串和 Symbol 类型属性都会被复制。
    ```javascript 
       Object.assign(Point.prototype, {
        toString(){},
        toValue(){}
      });
34. constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。
    ```javascript
       class Foo {
        constructor() {
          return Object.create(null);
        }
      }

      new Foo() instanceof Foo
      // false
35. 类的属性和方法，除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。与 ES5 一样，类的所有实例共享一个原型对象。ES2022 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在constructor()方法里面的this上面，也可以定义在类内部的最顶层。
    ```javascript 
        class IncreasingCounter {
          _count = 0;
          get value() {
            console.log('Getting the current value!');
            return this._count;
          }
          increment() {
            this._count++;
          }
        }
    上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。
36. 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。存值函数和取值函数是设置在属性的 Descriptor 对象上的。class 语法定义的存取器默认是 enumerable: true 和 configurable: true
    ```javascript 
        class CustomHTMLElement {
        constructor(element) {
          this.element = element;
        }

        get html() {
          return this.element.innerHTML;
        }

        set html(value) {
          this.element.innerHTML = value;
        }
      }
      Object.defineProperty(Person.prototype, 'html', {
          get: function() {
            return this.element.innerHTML;
          },
          set: function(value) {
            this.element.innerHTML = value;
          },
          enumerable: true,  // 注意这个属性
          configurable: true // 注意这个属性
      });
      var descriptor = Object.getOwnPropertyDescriptor(
        CustomHTMLElement.prototype, "html"
      );
      // {
      //   get: [Function: get html],
      //   set: [Function: set html],
      //   enumerable: true,    // 注意这里是 true
      //   configurable: true   // 注意这里是 true
      // }
      "get" in descriptor  // true
      "set" in descriptor  // true
37. 类的属性名，可以采用表达式。
    ```javascript 
       let methodName = 'getArea';
        class Square {
          constructor(length) {
            // ...
          }

          [methodName]() {
            // ...
          }
        } 
